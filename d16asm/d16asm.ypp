%{
#include "d16asm.h"

list<dwPayload> listPayload;
list<Macro> lMacros;

bool bMacro = false;

%}

%union {
	long l;
	char *s;
}

%token <l> TOK_NUMBER
%token <s> TOK_IDENTIFIER TOK_LITERAL TOK_LABEL TOK_MACRO TOK_MACROARG TOK_MACROEND
%token TOK_EOL
/* directives */
%token TOK_ORG TOK_EQU TOK_DW TOK_DS
/* keywords */

%token TOK_DUP TOK_SWAP TOK_DROP TOK_JMPZ TOK_JMPNZ TOK_JMPL TOK_JMP
%token TOK_BRAZ TOK_BRANZ TOK_BRAL TOK_CALL TOK_RET TOK_PUSHRS TOK_DROPRS
%token TOK_POPRS TOK_LOAD TOK_STORE TOK_PUSHPC TOK_PUSHSP TOK_POPSP TOK_ADD
%token TOK_ADC TOK_SUB TOK_SBC TOK_AND TOK_OR TOK_XOR TOK_INV TOK_LSL TOK_LSR
%token TOK_PICK

%start S

%%

S:
 | S line
 ;


line: TOK_EOL
    | keyword
    | TOK_NUMBER     { addNumber($1); }
    | TOK_LABEL      { addLabel($1); }
    | identifier
    | directive
    ;

identifier: TOK_IDENTIFIER '(' TOK_NUMBER ')' { addIdentifier($1, $3); }
          | TOK_IDENTIFIER { addIdentifier($1, 0); }
          ;


keyword: TOK_DUP     { addKeyword(d16::OPCODES::DUP); }
       | TOK_DROP    { addKeyword(d16::OPCODES::DROP); }
       | TOK_JMPZ    { addKeyword(d16::OPCODES::JMPZ); }
       | TOK_JMPNZ   { addKeyword(d16::OPCODES::JMPNZ); }
       | TOK_JMPL    { addKeyword(d16::OPCODES::JMPL); }
       | TOK_JMP     { addKeyword(d16::OPCODES::JMP); }
       | TOK_BRAZ    { addKeyword(d16::OPCODES::BRAZ); }
       | TOK_BRANZ   { addKeyword(d16::OPCODES::BRANZ); }
       | TOK_BRAL    { addKeyword(d16::OPCODES::BRAL); }
       | TOK_CALL    { addKeyword(d16::OPCODES::CALL); }
       | TOK_RET     { addKeyword(d16::OPCODES::RET); }
       | TOK_PUSHRS  { addKeyword(d16::OPCODES::PUSHRS); }
       | TOK_DROPRS  { addKeyword(d16::OPCODES::DROPRS); }
       | TOK_POPRS   { addKeyword(d16::OPCODES::POPRS); }
       | TOK_LOAD    { addKeyword(d16::OPCODES::LOAD); }
       | TOK_STORE   { addKeyword(d16::OPCODES::STORE); }
       | TOK_PUSHPC  { addKeyword(d16::OPCODES::PUSHPC); }
       | TOK_PUSHSP  { addKeyword(d16::OPCODES::PUSHSP); }
       | TOK_POPSP   { addKeyword(d16::OPCODES::POPSP); }
       | TOK_ADD     { addKeyword(d16::OPCODES::ADD); }
       | TOK_ADC     { addKeyword(d16::OPCODES::ADC); }
       | TOK_SUB     { addKeyword(d16::OPCODES::SUB); }
       | TOK_SBC     { addKeyword(d16::OPCODES::SBC); }
       | TOK_AND     { addKeyword(d16::OPCODES::AND); }
       | TOK_OR      { addKeyword(d16::OPCODES::OR); }
       | TOK_XOR     { addKeyword(d16::OPCODES::XOR); }
       | TOK_INV     { addKeyword(d16::OPCODES::INV); }
       | TOK_LSL     { addKeyword(d16::OPCODES::LSL); }
       | TOK_LSR     { addKeyword(d16::OPCODES::LSR); }
       | pick
       | swap
       ;

pick: TOK_PICK '(' TOK_NUMBER ')' { addPick( $3 ); }
    ;

swap: TOK_SWAP '(' TOK_NUMBER ')' { addSwap( $3 ); }
    ;

directive: TOK_ORG TOK_NUMBER TOK_EOL { addOrg( $2 ); }
         | TOK_DS TOK_NUMBER TOK_EOL  { addDs($2); }
         | equ
         | dw
         | macro
         ;


equ: TOK_EQU TOK_IDENTIFIER TOK_NUMBER TOK_EOL { addEqu( $2, $3 ); }
   ;


dw: TOK_DW dwdata { addDw(); listPayload.clear(); }
  ;


dwdata: TOK_NUMBER                  { listPayload.push_back( dwPayload($1) ); }
      | TOK_LITERAL                 { listPayload.push_back( dwPayload($1, dwPayload::Literal) ); }
      | TOK_IDENTIFIER              { listPayload.push_back( dwPayload($1, dwPayload::Ident) ); }
      | dwdata ',' TOK_NUMBER       { listPayload.push_back( dwPayload($3) ); }
      | dwdata ',' TOK_LITERAL      { listPayload.push_back( dwPayload($3, dwPayload::Literal) ); }
      | dwdata ',' TOK_IDENTIFIER   { listPayload.push_back( dwPayload($3, dwPayload::Ident) ); }
      ;

macro: TOK_MACRO { lMacros.push_back(Macro($1)); bMacro = true; } macrodata { bMacro = false; }
     ;

macrodata: TOK_LITERAL macrodata { printf("%s\n", $1); }
         | TOK_EOL macrodata
         | TOK_IDENTIFIER macrodata { printf("%s\n", $1); }
         | TOK_NUMBER macrodata { printf("%ld\n",$1); }
         | TOK_MACROARG macrodata { printf("%s\n",$1); }
         | TOK_MACROEND
         ;
%%

void yyerror(char *s, ...) {
    va_list ap;
    va_start(ap, s);
    fprintf(stderr, "Error on line %d: ", yylineno);
    vfprintf(stderr, s, ap);
    fprintf(stderr, "\n");
    va_end(ap);
}
